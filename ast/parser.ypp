%{
    #include <cstdio>
    #include <cstdlib>
    #include <stdio.h>

    #include "ast.hpp"
    #include "primitive.hpp"
    #include "symtab.hpp"

    #define YYDEBUG 1

    extern Program_ptr ast;
    int yylex(void);
    void yyerror(const char *);
%}

/* Enables verbose error messages */
%error-verbose

%start Start
%token BOOLEAN
%token CHAR
%token INTEGER
%token STRING
%token INTPTR
%token CHARPTR
%token IF
%token ELSE
%token WHILE
%token VAR
%token PROCEDURE
%token RETURN

%token ANDAND
%token SLASH
%token EQUAL
%token EQEQ
%token BIGER
%token BIGERE
%token LESS
%token LESSE
%token MINUS
%token NOT
%token NOTEQUAL
%token OROR
%token PLUS
%token TIMES
%token ADDRESS
%token DEREF

%token SEMI
%token COLON
%token COMMA
%token ABS
%token LBRACE
%token RBRACE
%token LP
%token RP
%token LBRAKET
%token RBRAKET

%token C
%token STR
%token TRUE
%token FALSE
%token INT
%token ID

%token CL
%token CR

%left  OROR
%left  ANDAND
%left  EQEQ NOTEQUAL
%left  BIGER BIGERE LESS LESSE 
%left  PLUS MINUS
%left  TIMES DIVIDE

%right EQUAL
%right NOT


%%


/*------------------------- START ----------------------------*/

Start   	: 	procedure p_more  { $2.u_proc_list->push_front($1.u_proc); ast = new ProgramImpl($2.u_proc_list); }
        	;

p_more  	: 	procedure p_more  { $2.u_proc_list->push_front($1.u_proc); $$.u_proc_list = $2.u_proc_list; }
        	|                     { $$.u_proc_list = new std::list<Proc_ptr>; }
        	;

procedure :   PROCEDURE ID LP para_list RP RETURN type LBRACE body_of_p RBRACE 
              { $$.u_proc=new ProcImpl(new SymName($2.u_base_charptr), $4.u_decl_list, $7.u_type, $9.u_procedure_block); }
        	;

para_list : 	ID id_more COLON type para_more 
              { 
                $3.u_symname_list = new std::list<SymName_ptr>(); 
                $3.u_symname_list->push_back(new SymName($1.u_base_charptr)); 
                $3.u_symname_list->insert($3.u_symname_list->begin(), $2.u_symname_list->begin(), $2.u_symname_list->end()); 
                $5.u_decl_list->push_front(new DeclImpl($3.u_symname_list, $4.u_type)); 
                $$.u_decl_list = $5.u_decl_list; 
              }
       		|   { $$.u_decl_list = new std::list<Decl_ptr>(); } 
       		;

id_more		:	COMMA ID id_more   { $3.u_symname_list->push_front(new SymName($2.u_base_charptr)); $$.u_symname_list = $3.u_symname_list; }
			    |                    { $$.u_symname_list = new std::list<SymName_ptr>(); }
			    ;

para_more   : 	SEMI para_list    { $$.u_decl_list = $2.u_decl_list; }
            |                     { $$.u_decl_list = new std::list<Decl_ptr>(); }
            ;

type   		: 	BOOLEAN    { $$.u_type = new TBoolean(); }
       		| 	CHAR       { $$.u_type = new TCharacter(); }
      		| 	INTEGER    { $$.u_type = new TInteger(); }
       		| 	CHARPTR    { $$.u_type = new TCharPtr(); }
       		| 	INTPTR     { $$.u_type = new TIntPtr(); }
      		;

/*------------------ body of procedure ----------------------*/

body_of_p	:	  p_nest var_dec statements return  
              { $$.u_procedure_block = new Procedure_blockImpl( $1.u_proc_list, $2.u_decl_list, $3.u_stat_list, $4.u_return_stat); }
			    ;

p_nest		:	  procedure p_nest    { $2.u_proc_list->push_front($1.u_proc); $$.u_proc_list = $2.u_proc_list; }
			    |	                      { $$.u_proc_list = new std::list<Proc_ptr>(); }
			    ;

var_dec 	:	  VAR ID id_more COLON dec_type SEMI var_dec
              {
                $3.u_symname_list->push_front(new SymName($2.u_base_charptr));
                $6.u_decl=new DeclImpl($3.u_symname_list, $5.u_type); 
                $7.u_decl_list->push_front($6.u_decl);
                $$.u_decl_list = $7.u_decl_list;
              }
			    |   { $$.u_decl_list = new std::list<Decl_ptr>(); }
			    ;

dec_type	:  	INTEGER                                  { $$.u_type = new TInteger(); }
          |   BOOLEAN                                  { $$.u_type = new TBoolean(); }
			    |	  CHARPTR                                  { $$.u_type = new TCharPtr(); }
          |   INTPTR                                   { $$.u_type = new TIntPtr(); }
          |   CHAR                                     { $$.u_type = new TCharacter(); }
	     		|	  STRING LBRAKET int_literal RBRAKET       { $$.u_type = new TString($3.u_primitive); }
		    	;

 /*---------------------- statements -------------------------*/

statements	:	statement statements     { $2.u_stat_list->push_front($1.u_stat); $$.u_stat_list=$2.u_stat_list; }
		      	|                          { $$.u_stat_list = new std::list<Stat_ptr>(); }
		      	;

statement 	:	  assignment SEMI        { $$.u_stat = $1.u_stat; }
			      |	  if                     { $$.u_stat = $1.u_stat; }
		      	|   while                  { $$.u_stat = $1.u_stat; }
		      	|	  code_block             { $$.u_stat = $1.u_stat; }
		      	;

return 		 : 	RETURN expression SEMI   { $$.u_return_stat = new Return($2.u_expr); }
			     ;

code_block	:	LBRACE var_dec statements  RBRACE
		      	;

 /*---------------------- assignment -------------------------*/

assignment 	: 	lhs EQUAL rhs;

lhs 		:	ID lhs_more
			|   DEREF LP expression RP
      |   DEREF ID
			;

lhs_more 	:   LBRAKET expression RBRAKET
			|	
			;

rhs 		: 	expression
			|	func_call
      | STR
			;

func_call 	: 	ID LP call_paras RP  
			;


expression 	: 	 expression_left expression_more
            |    unary expression
			      ;

expression_left   :   single
                  |   ABS expression ABS
                  |   LP expression RP
                  ;

expression_more	:	operator expression
                | compare expression
			          |
		          	;



single 		  : 	ID                { $$.u_expr = new Ident(new SymName($1.u_base_charptr)); }
            | 	TRUE              { $$.u_expr = new BoolLit(new Primitive($1.u_base_int)); }
            | 	FALSE             { $$.u_expr = new BoolLit(new Primitive($1.u_base_int)); }
            | 	INT               { $$.u_expr = new IntLit(new Primitive($1.u_base_int));  }
            | 	strptr            
            |	  C                 { $$.u_expr = new CharLit(new Primitive($1.u_base_int)); }
            |   ADDRESS ID
            |   ADDRESS strptr
            ;



call_paras  :   expression para_more
            |
            ;

para_more   :   COMMA call_paras
            ;

unary 		:	DEREF 
			|	PLUS
			|	MINUS
			|	NOT
			;

operator 	:	OROR
      | ANDAND
			|	PLUS
			|	MINUS
			|	TIMES
			|	DIVIDE
			;

compare :   BIGER
        |   BIGERE
        |   LESS
        |   LESSE
        |   EQEQ
        |   NOTEQUAL
        ;

strptr		:	ID LBRAKET expression RBRAKET			
			   ;


int_literal :   PLUS INT    { $$.u_primitive = new Primitive($2.u_base_int); }
            |   MINUS INT   { $$.u_primitive = new Primitive((-1) * $2.u_base_int); }
            |   INT         { $$.u_primitive = new Primitive($1.u_base_int); }
            ;

 /*---------------------- if else while -----------------------*/

if 			:	IF LP expression RP LBRACE b_o_n_s RBRACE
			| 	IF LP expression RP LBRACE b_o_n_s RBRACE ELSE LBRACE b_o_n_s RBRACE
			;

while 		:	WHILE LP expression RP LBRACE b_o_n_s RBRACE
			;

b_o_n_s 	:   statement   b_o_n_s
            |
            ;




/***********************************************************************************************************






TYPE :    INT   {$$.u_type=new TInteger();}
        | BOOL  {$$.u_type=new TBoolean();}
        ;

TYPE_2 : TYPE {$$.u_type=$1.u_type;}
        | INT_ARRAY {$$.u_type = $1.u_type;}
        ;

INT_ARRAY : INTARRAY LEFTBRACKET INTEGER RIGHTBRACKET {$$.u_type=new TIntArray(new Primitive($3.u_base_int));}
          ;
INT_ARRAY_EXP: IDENTIFIER LEFTBRACKET  {$$.u_symname=new SymName($1.u_base_charptr); 
             ;
ARRAY_EXP     : EXPR_ESSION RIGHTBRACKET    {$$.u_expr=$1.u_expr;}
              ;






IF_ :  IF_EXPR IF_BODY  {$$.u_stat=new IfNoElse($1.u_expr,$2.u_nested_block);}
    ;

IF_EXPR: IF LEFTPAREN EXPR_ESSION RIGHTPAREN {$$.u_expr= $3.u_expr;}
        ;

IF_BODY : LEFTBRACE BODY_STATEMENTS RIGHTBRACE   {$$.u_nested_block=new Nested_blockImpl($2.u_stat_list);}
        ;

IF_ELSE : IF_EXPR IF_BODY ELSE LEFTBRACE BODY_STATEMENTS RIGHTBRACE {$$.u_stat=new IfWithElse($1.u_expr,$2.u_nested_block,new Nested_blockImpl($5.u_stat_list));}
        ;


ASIGN_MENT : IDENTIFIER ASSIGNMENT EXPR_ESSION {$$.u_stat=new Assignment(new SymName($1.u_base_charptr),$3.u_expr);}
            | INT_ARRAY_EXP ARRAY_EXP ASSIGNMENT EXPR_ESSION  {$$.u_stat=new ArrayAssignment($1.u_symname,$2.u_expr,$4.u_expr);}
            ;

EXPR_ESSION : LEFTPAREN EXPR_ESSION RIGHTPAREN  {$$.u_expr=$2.u_expr;}
            | ABSOLUTEVALUE EXPR_ESSION ABSOLUTEVALUE {$$.u_expr=$2.u_expr;}
            | MINUS EXPR_ESSION %prec NOT {$$.u_expr=new Uminus($2.u_expr);}
            | NOT EXPR_ESSION   %prec NOT {$$.u_expr=new Not($2.u_expr);}
            | EXPR_ESSION PLUS EXPR_ESSION {$$.u_expr=new Plus($1.u_expr,$3.u_expr);}
            | EXPR_ESSION MINUS EXPR_ESSION {$$.u_expr=new Minus($1.u_expr,$3.u_expr);}
            | EXPR_ESSION TIMES EXPR_ESSION {$$.u_expr=new Times($1.u_expr,$3.u_expr);}
            | EXPR_ESSION DIVIDE EXPR_ESSION {$$.u_expr=new Div($1.u_expr,$3.u_expr);}
            | EXPR_ESSION OROR EXPR_ESSION   {$$.u_expr=new Or($1.u_expr,$3.u_expr);}
            | EXPR_ESSION ANDAND EXPR_ESSION {$$.u_expr=new And($1.u_expr,$3.u_expr);}
            | EXPR_ESSION EQEQ EXPR_ESSION   {$$.u_expr=new Compare($1.u_expr,$3.u_expr);}
            | EXPR_ESSION GT EXPR_ESSION     {$$.u_expr=new Gt($1.u_expr,$3.u_expr);}
            | EXPR_ESSION GTE EXPR_ESSION    {$$.u_expr=new Gteq($1.u_expr,$3.u_expr);}
            | EXPR_ESSION LT EXPR_ESSION     {$$.u_expr=new Lt($1.u_expr,$3.u_expr);}
            | EXPR_ESSION LTE EXPR_ESSION    {$$.u_expr=new Lteq($1.u_expr,$3.u_expr);}
            | EXPR_ESSION NE EXPR_ESSION     {$$.u_expr=new Noteq($1.u_expr,$3.u_expr);}
            | SINGLE_EXPRESSION { $$.u_expr=$1.u_expr;}
            ;

SINGLE_EXPRESSION : INTEGER         {$$.u_expr=new IntLit(new Primitive($1.u_base_int)); }
                  | TRUE            {$$.u_expr=new BoolLit(new Primitive($1.u_base_int));}
                  | FALSE           {$$.u_expr=new BoolLit(new Primitive($1.u_base_int));}
                  | IDENTIFIER      { $$.u_expr=new Ident(new SymName($1.u_base_charptr));}
                  | INT_ARRAY_EXP ARRAY_EXP  {$$.u_expr=new ArrayAccess($1.u_symname,$2.u_expr);}
                  ;


FUNCTION_CALL : IDENTIFIER ASSIGNMENT IDENTIFIER LEFTPAREN IN_PARAMS RIGHTPAREN {$$.u_stat=new Call(new SymName($1.u_base_charptr),new SymName($3.u_base_charptr), $5.u_expr_list);}
                | INT_ARRAY_EXP ARRAY_EXP ASSIGNMENT IDENTIFIER LEFTPAREN IN_PARAMS RIGHTPAREN {$$.u_stat=new ArrayCall($1.u_symname, $2.u_expr, new SymName($4.u_base_charptr), $6.u_expr_list);}
                ;

IN_PARAMS : EXPR_ESSION NEXT_PARAM  {$2.u_expr_list->push_front($1.u_expr);$$.u_expr_list=$2.u_expr_list;}
          | {$$.u_expr_list=new list<Expr_ptr>();}
          ;

NEXT_PARAM : COMMA EXPR_ESSION NEXT_PARAM {$3.u_expr_list->push_front($2.u_expr); $$.u_expr_list=$3.u_expr_list;}
            |   {$$.u_expr_list=new list<Expr_ptr>();}
            ;


***************************************************/



%%

/** You shall not pass!
 *  You should not  have to do or edit anything past this.
 */

extern int yylineno;

void yyerror(const char *s)
{
    fprintf(stderr, "%s at line %d\n", s, yylineno);
    return;
}
