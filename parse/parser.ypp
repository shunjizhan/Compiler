%{
    #include <stdio.h>
    #include <stdlib.h>
    #define YYDEBUG 1

    int yylex(void);     /* lexical analyzer */
    void yyerror(const char *);
%}

/* Enables verbose error messages */
%error-verbose

%start Start
%token BOOL
%token CHAR
%token INTEGER
%token STRING
%token INTPTR
%token CHARPTR
%token IF
%token ELSE
%token WHILE
%token VAR
%token PROCEDURE
%token RETURN

%token ANDAND
%token SLASH
%token EQUAL
%token EQEQ
%token BIGER
%token BIGERE
%token LESS
%token LESSE
%token MINUS
%token NOT
%token NOTEQUAL
%token OROR
%token PLUS
%token TIMES
%token ADDRESS
%token DEREF

%token SEMI
%token COLON
%token COMMA
%token OR
%token LBRACE
%token RBRACE
%token LP
%token RP
%token LBRAKET
%token RBRAKET

%token C
%token TRUE
%token FALSE
%token INT
%token ID


%left  OROR
%left  ANDAND
%left  EQEQ NOTEQUAL
%left  BIGGER BIGGERE LESS LESSE 
%left  PLUS MINUS
%left  TIMES DIVIDE

%right EQUAL
%right NOT


%%

/***
Start   :	BOOL CHAR INTEGER STRING INTPTR CHARPTR IF ELSE WHILE  VAR PROCEDURE RETURN ANDAND SLASH EQUAL EQEQ BIGER BIGERE LESS LESSE MINUS NOT NOTEQUAL OROR PLUS TIMES ADDRESS DEREF SEMI COLON COMMA OR LBRACE RBRACE LP RP LBRAKET RBRAKET   C C C C C TRUE FALSE INT  INT INT INT  INT  INT INT INT INT INT  INT INT INT INT  INT  INT INT INT INT INT  INT  INT INT INT INT ID ID ID ID ID ID ID ID ID ID ID ID ID ID ID ID ID ID ID ID ID ID ID ID ID ID ID ID ID ID  ID ID ID ID ID ID ID{printf("accepted!\n")}
        ;
***/

Start   	: 	procedure p_more {printf("accepted!\n");}
        	;

p_more  	: 	procedure p_more
        	| 
        	;

procedure   :   PROCEDURE ID LP para_list RP RETURN type LBRACE body_of_p RBRACE
        	;

para_list   : 	ID id_more COLON type para_more
       		|
       		;

id_more		:	COMMA ID id_more
			|
			;

para_more   : 	SEMI para_list
            |
            ;

type   		: 	BOOL
       		| 	CHAR
      		| 	INTEGER
       		| 	CHARPTR
       		| 	INTPTR
      		;

/*------------------ body of procedure ----------------------*/

body_of_p	:	p_nest var_dec statements return
			;

p_nest		:	procedure p_nest
			|	
			;

var_dec 	:	VAR ID id_more COLON var_type SEMI var_dec
			|
			;

statements	:	statement statements
			|
			;

return 		: 	RETURN expression SEMI
			;

/*---------------------- statements -------------------------*/

statement 	:	{printf("assignment\n");} assignment SEMI
			|	{printf("f_call\n");}     f_call SEMI
			|	{printf("if\n");}         if
			|	{printf("if_else\n");}     if_else
			|	{printf("while\n");}         while
			|	{printf("code_block\n");}  code_block
			|
			;

assignment  : 	lhs EQUAL expression 
            | 	lhs EQUAL strptr 
            ;

f_call   	: 	ID EQUAL func
            | 	intptr EQUAL func /* intptr has ID as its first*/
            ;

func		:	ID LP call_paras RP
			;

if 			:	IF LP expression RP LBRACE b_o_n_s RBRACE
			;

if_else 	:	if ELSE LBRACE b_o_n_s RBRACE
			;

while 		:	WHILE LP expression RP LBRACE b_o_n_s RBRACE
			;

b_o_n_s 	:   statement   b_o_n_s
            |
            ;

code_block	:	LBRACE content RBRACE
			;

content		:	code_block2 var_dec code_block2 RBRACE code_block2
			;

code_block2	:	LBRACE content RBRACE
			|
			;

/*------------------------------------------------------------*/

lhs			: {printf("ID\n");}	    ID 
			|	{printf("strptr\n");}  strptr	
			|	{printf("DEREF\n");}   DEREF expression   		/* ?????????????? */
			;

var_type	:	STRING LBRAKET int_literal RBRAKET
			|   INTPTR LBRAKET int_literal RBRAKET
			|	BOOL
			|	CHAR
			|	INTEGER
			;


int_literal :	expression   			/* ?????????????? */
			;


call_paras  : 	expression para_more
            |
            ;

para_more   :   COMMA call_paras
            |
            ;

expression 	: 	single single_more 
			;

single_more	:	operator single single_more
			|
			;

single 		: 	INT
            | 	TRUE
            | 	FALSE
            | 	ID
            | 	intptr
            | 	strptr
            | 	unarys single
            ;

intptr		:	ID LBRAKET expression RBRAKET			/* ?????????????? */
			;

strptr		:	ID LBRAKET expression RBRAKET			/* ?????????????? */
			;

unarys		:	unary unarys
			|
			;

unary 		:	NOT
			|	PLUS
			|	MINUS
			|	ADDRESS
			|	DEREF
			;

operator 	:	NOT
			|	PLUS
			|	MINUS
			|	ADDRESS
			|	DEREF
			|	TIMES
			|	DIVIDE
			;







/*****

INT_ARRAY : INTARRAY LBRAKET INTEGER RBRAKET
          ;







expression : MULT_EXPRESSION
            | LP expression RP OPE_RATOR
            | NOT LP expression RP OPE_RATOR
            | ABSOLUTEVALUE expression ABSOLUTEVALUE OPE_RATOR
            ;



                  
MULT_EXPRESSION   : single OPE_RATOR
                  ;

OPE_RATOR         : 
                  | PLUS expression
                  | MINUS expression
                  | TIMES expression
                  | DIVIDE expression
                  | OROR expression
                  | ANDAND expression
                  | EQEQ expression
                  | GT expression
                  | GTE expression
                  | LT expression
                  | LTE expression
                  | NE expression
                  ;



******/




%%

/** You shall not pass!
 *  You should not  have to do or edit anything past this.
 */

extern int yylineno;

void yyerror(const char *s)
{
    fprintf(stderr, "%s at line %d\n", s, yylineno);
    return;
}
